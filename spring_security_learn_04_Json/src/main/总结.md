# maxin 混入
# 1. 什么是混入
Jackson Mixin 是一种在类中添加 Jackson 注解而不修改实际类的机制。
它是为了解决在无法修改类的情况下，如使用第三方类时，添加 Jackson 序列化所需的所有必要部分的问题。
Mixin 类可以是抽象类，也可以是接口，可以用于 Jackson 序列化和反序列化，并需要将其添加到 ObjectMapper 配置中
# 2. 为什么要混入
使用 Jackson Mixin 的**原因主要是为了在不修改原有类**的基础上，为其添加 Jackson 注解，从而控制其序列化和反序列化的行为。
这在**处理*第三方类库或无法修改的类时*特别有用**。通过 Jackson Mixin，我们可以将特定的序列化或反序列化配置应用于这些类，而无需修改其源代码。

此外，Jackson Mixin 还可以帮助我们实现更灵活的序列化和反序列化策略。
例如，我们可以根据不同的需求创建多个 Mixin 类，每个类包含不同的注解和配置，然后在运行时根据情况选择使用哪一个 Mixin。
这样，我们可以轻松地调整序列化和反序列化的行为，以满足各种不同的业务需求。
# 3. 如何混入
0. 现在有一个类 OAuth2AccessToken（不管是自己创建的还是三方的）
现在要修改这个类的序列化反序列化行为，但是又不能修改这个类，为了解决这个问题，就可以使用混入
```java
@com.fasterxml.jackson.databind.annotation.JsonSerialize(using = OAuth2AccessTokenJackson2Serializer.class)
@com.fasterxml.jackson.databind.annotation.JsonDeserialize(using = OAuth2AccessTokenJackson2Deserializer.class)
public interface OAuth2AccessToken {
}
```
1. 创建一个 mixin 类（抽象类或接口），添加 Jackson 注解
```java
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class")
@JsonSerialize(using = MysOAuth2AccessTokenJacksonSerializer.class)
@JsonDeserialize(using = MyOAuth2AccessTokenJacksonDeserializer.class)
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY, getterVisibility = JsonAutoDetect.Visibility.NONE,
        isGetterVisibility = JsonAutoDetect.Visibility.NONE)
@JsonIgnoreProperties(ignoreUnknown = true)
public abstract class MyOAuth2AccessTokenJacksonMixin {
}
```
2. 将 mixin 类注册到 ObjectMapper 中
```
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.addMixIn(OAuth2AccessToken.class, MyOAuth2AccessTokenJacksonMixin.class);
```
# 4. 混入的原理


# 5. 混入的应用场景
使用混入的场景：
1. 为第三方类库添加 Jackson 注解
2. 为无法修改的类添加 Jackson 注解
上面2种情况说白了就是一种，类序列化反序列化行为不符合我们的要求，但是又不能修改这个类，所以就使用混入来解决这个问题
## 5.1 没有无参构造方法，有参构造方法的参数都是简单的类型
```java
public class MyUser {
    private String username;
    private String realname;

    public MyUser(String username, String realname) {
        this.username = username;
        this.realname = realname;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getRealname() {
        return realname;
    }

    public void setRealname(String realname) {
        this.realname = realname;
    }
}
```
### 5.1.1 mixin 中使用 @JsonCreator 注解指定构造方法
```java
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class")
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY, getterVisibility = JsonAutoDetect.Visibility.NONE,
        isGetterVisibility = JsonAutoDetect.Visibility.NONE, creatorVisibility = JsonAutoDetect.Visibility.ANY) // 扫描所有构造方法
@JsonIgnoreProperties(ignoreUnknown = true)
abstract class MyUserMixinWithJsonCreator {

    /**
     * @JsonCreator 注解表示这个构造函数是用于从JSON创建对象。
     * @JsonProperty 注解用于指定JSON属性名和Java参数名之间的映射。例如，JSON中的"oauth2Request"属性将被映射到Java参数 storedRequest。
     */
    @JsonCreator
    public MyUserMixinWithJsonCreator(@JsonProperty("username") String username,
                                      @JsonProperty("realname") String realname) {
    }
}
```
### 5.1.2 自定以反序列化类
```java
public class MyUserDeserializer extends StdDeserializer<MyUser> {

    protected MyUserDeserializer() {
        super(MyUser.class);
    }

    /**
     * 参考 {@link org.springframework.security.oauth2.common.OAuth2AccessTokenJackson2Deserializer}
     */
    @Override
    public MyUser deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
        String username = null;
        String realname = null;
        while (p.nextToken() != JsonToken.END_OBJECT) {
            String name = p.getCurrentName();
            p.nextToken();
            if ("username".equals(name)) {
                username = p.getText();
            } else if ("realname".equals(name)) {
                realname = p.getText();
            }
        }
        return new MyUser(username, realname);
    }

    /**
     * 使用了@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class") 注解后
     * 最好重写这个方法，避免 json 串中没有 @class 属性时报错 Missing type id when trying to resolve subtype of  ...
     * 因为使用了 @JsonTypeInfo 注解后，会将实际的反序列化类包装成一个 {@link TypeWrappedDeserializer} 对象
     * @see TypeWrappedDeserializer#deserialize( JsonParser, DeserializationContext) -> 实际的反序列化类执行的是 deserializeWithType 方法
     */
    @Override
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        // TODO 按实际业务来对 typeDeserializer 进行处理
        String propertyName = typeDeserializer.getPropertyName();
        System.out.println("typeId：" + propertyName);
        TypeIdResolver typeIdResolver = typeDeserializer.getTypeIdResolver();
        System.out.println("typeIdResolver：" + typeIdResolver);
        Class<?> defaultImpl = typeDeserializer.getDefaultImpl();
        System.out.println("defaultImpl：" + defaultImpl);
        return deserialize(p, ctxt);
    }
}
```

### 5.1.3 测试
```java
    public class testMixin {
    public void testMixinWithJsonCreator() throws JsonProcessingException {
        /**
         * MyUser 没有无参构造函数
         */
        MyUser myUser = new MyUser("test", "hello");
        ObjectMapper objectMapper = new ObjectMapper();
        /**
         * 添加 Mixin 使用 @JsonCreator 注解来指定反序列化时创建对象的构造函数
         * @JsonTypeInfo 可以不用，像我这里使用了 JsonTypeInfo.Id.CLASS 的话
         * 1. 会在序列化的时候往 json 串中添加一个 @class 属性，值为对象类型全名
         * 2. 如果反序列化的时候 json 串中没有这个 @class 属性，那么会直接报错 Missing type id
         * 3. 如果反序列化的时候 json 串中 @class 属性值不是 readValue 中需要的类型的相同类型或者子类型则会报错
         * Could not resolve type id '' as a subtype of `com.example.demo.testJsonCreator.MyUser`: no such class found
         */
        objectMapper.addMixIn(MyUser.class, MyUserMixinWithJsonCreator.class);

        /**
         * 没有加 Mixin 可以序列化
         */
        String s = objectMapper.writeValueAsString(myUser);
        System.out.println(s);

        String s = "{\"@class\": \"com.example.demo.testMixin.MyUser\", \"username\":\"test\",\"realname\":\"hello\"}";
        /**
         * 没有加 Mixin 反序列化报错
         */
        MyUser jsonUser = objectMapper.readValue(s, MyUser.class);
        System.out.println(jsonUser);
    }
}
```
## 5.2 mixin 中指定序列化反序列化的方式
### 5.2.1 mixin 中指定序列化反序列化的方式 @JsonDeserialize 和 @JsonSerialize
这里我只写了 @JsonDeserialize 的例子
```java
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class")
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY, getterVisibility = JsonAutoDetect.Visibility.NONE,
        isGetterVisibility = JsonAutoDetect.Visibility.NONE)
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonDeserialize(using = MyUserDeserializer.class)
abstract class MyUserMixin {
}
```
### 5.2.2 测试
```java
public class testMixin {
    public void testMixinWithCustomSerOrDeser() throws JsonProcessingException {
        /**
         * MyUser 没有无参构造函数
         */
        MyUser myUser = new MyUser("test", "hello");
        ObjectMapper objectMapper = new ObjectMapper();
        /**
         * 添加 Mixin
         * @JsonTypeInfo 可以不用，像我这里使用了 JsonTypeInfo.Id.CLASS 的话
         * 1. 会在序列化的时候往 json 串中添加一个 @class 属性，值为对象类型全名
         * 2. 如果反序列化的时候 json 串中没有这个 @class 属性，那么会直接报错 Missing type id
         * 3. 如果反序列化的时候 json 串中 @class 属性值不是 readValue 中需要的类型的相同类型或者子类型则会报错
         * Could not resolve type id '' as a subtype of `com.example.demo.testJsonCreator.MyUser`: no such class found
         * 4. @class 正确加上后，报错没有无参构造方法: Cannot construct instance of `com.example.demo.testMixin.MyUser` (no Creators, like default constructor, exist)
         *     - 所以需要自己实现反序列类（MyUserDeserializer），在 MyUserMixin 上加上 @JsonDeserialize(using = MyUserDeserializer.class)
         *     - 自己实现 deserializeWithType 后 json 串中的 @class 不加也行，因为没有走验证 类型匹配的方法，当然如果自己实行的代码中调用了相应的方法的化还是得加上
         */
        objectMapper.addMixIn(MyUser.class, MyUserMixin.class);

        /**
         * 没有加 Mixin 可以序列化
         * 加入 Mixin 可以序列化，json 串中添加一个 @class 属性，值为 MyUser 类型全名
         */
        String s = objectMapper.writeValueAsString(myUser);
        System.out.println(s);

        String json = "{\"@class\":\"com.example.demo.testMixin.MyUser\",\"username\":\"test\",\"realname\":\"hello\"}";
        /**
         * 没有加 Mixin 反序列化报错
         * 加 Mixin 反序列化也会报错：
         * 1. json 串没有 @class 值报 type id missing，@class 值不是同一类型报错：Could not resolve type id '' as a subtype of
         * 2. @class 正确加上后，报错没有无参构造方法: Cannot construct instance of `com.example.demo.testMixin.MyUser` (no Creators, like default constructor, exist)
         * 3. 所以需要自己实现反序列类（MyUserDeserializer），在 MyUserMixin 上加上 @JsonDeserialize(using = MyUserDeserializer.class)
         *    - 自己实现 deserializeWithType 后 json 串中的 @class 不加也行，因为没有走验证 类型匹配的方法，当然如果自己实行的代码中调用了相应的方法的化还是得加上
         */
        MyUser jsonUser = objectMapper.readValue(json, MyUser.class);
        System.out.println(jsonUser);
    }
}
```

# 6. @JsonTypeInfo 注解
## 6.1 作用
@JsonTypeInfo 注解用于指定序列化和反序列化时的类型信息。
## 6.2 属性
1. use：指定类型信息的类型，可选值如下：
    1. JsonTypeInfo.Id.CLASS：序列化和反序列化时使用类的全限定名作为类型信息。
    2. JsonTypeInfo.Id.MINIMAL_CLASS：序列化和反序列化时使用类的简单名称作为类型信息。
    3. JsonTypeInfo.Id.NAME：序列化和反序列化时使用类的简单名称作为类型信息，同时还会在序列化时将类型信息作为属性添加到 JSON 中。
    4. JsonTypeInfo.Id.NONE：不使用类型信息。
    5. JsonTypeInfo.Id.CUSTOM：自定义类型信息。
2. include：指定类型信息的包含方式，可选值如下：
    1. JsonTypeInfo.As.PROPERTY：将类型信息作为属性添加到 JSON 中。
    2. JsonTypeInfo.As.EXISTING_PROPERTY：将类型信息作为已存在的属性添加到 JSON 中。
   3. JsonTypeInfo.As.EXTERNAL_PROPERTY：将类型信息作为外部属性添加到 JSON 中。
   4. JsonTypeInfo.As.WRAPPER_ARRAY：将类型信息作为数组添加到 JSON 中。
   5. JsonTypeInfo.As.WRAPPER_OBJECT：将类型信息作为属性添加到 JSON 中。
3. property：指定类型信息的属性名称。
4. visible：指定类型信息是否可见。
5. defaultImpl：指定在反序列化过程中如果没有类型标识符或者无法将类型标识符映射到已注册的类型时，应该使用的默认实现类。

## 6.3 使用
### 6.3.1 使用 JsonTypeInfo.Id.CLASS
```java
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class")
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY, getterVisibility = JsonAutoDetect.Visibility.NONE,
        isGetterVisibility = JsonAutoDetect.Visibility.NONE)
@JsonIgnoreProperties(ignoreUnknown = true)
abstract class MyUserMixin {
}
```
#### 序列化
1. 会在 json 串中添加一个 @class 属性，值为对象类型全名
```json
{"@class":"com.example.demo.testMixin.MyUser","username":"test","realname":"hello"}
```
2. 如果 mixin 中使用 @JsonSerialize(using = MyUserSerializer.class) 指定了序列化类，重写 serializeWithType 方法
不然会报错：Type id handling not implemented for type com.example.demo.testMixin.MyUser
```java
public class MyUserSerializer extends StdSerializer<MyUser> {
    protected MyUserSerializer() {
        super(MyUser.class);
    }
    @Override
    public void serialize(MyUser value, JsonGenerator gen, SerializerProvider provider) throws IOException {
        System.out.println("serialize");
        gen.writeStartObject();
        gen.writeStringField("username", value.getUsername());
        gen.writeStringField("realname", value.getRealname());
        gen.writeEndObject();}

    @Override
    public void serializeWithType(MyUser value, JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException {
        System.out.println("serializeWithType");
        serialize(value, gen, serializers);
    }
}
```
#### 反序列化
1. json 串中没有 @class 属性报 type id missing
2. json 串中 @class 属性值和 readValue 的类型不是同一类型或者子类型则会报错：Could not resolve type id '' as a subtype of
3. 如果 mixin 中使用 @JsonDeserialize(using = MyUserDeserializer.class) 指定了反序列化类，最好重写 deserializeWithType 方法避免json 串中没有 @class 属性时报错 Missing type id
```java
public class MyUserDeserializer extends StdDeserializer<MyUser> {

    protected MyUserDeserializer() {
        super(MyUser.class);
    }

    /**
     * 参考 {@link org.springframework.security.oauth2.common.OAuth2AccessTokenJackson2Deserializer}
     */
    @Override
    public MyUser deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
        String username = null;
        String realname = null;
        while (p.nextToken() != JsonToken.END_OBJECT) {
            String name = p.getCurrentName();
            p.nextToken();
            if ("username".equals(name)) {
                username = p.getText();
            } else if ("realname".equals(name)) {
                realname = p.getText();
            }
        }
        return new MyUser(username, realname);
    }

    /**
     * 使用了@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class") 注解后
     * 最好重写这个方法，避免 json 串中没有 @class 属性时报错 Missing type id when trying to resolve subtype of  ...
     * 因为使用了 @JsonTypeInfo 注解后，会将实际的反序列化类包装成一个 {@link TypeWrappedDeserializer} 对象
     * @see TypeWrappedDeserializer#deserialize( JsonParser, DeserializationContext) -> 实际的反序列化类执行的是 deserializeWithType 方法
     */
    @Override
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        // TODO 按实际业务来对 typeDeserializer 进行处理
        String propertyName = typeDeserializer.getPropertyName();
        System.out.println("typeId：" + propertyName);
        TypeIdResolver typeIdResolver = typeDeserializer.getTypeIdResolver();
        System.out.println("typeIdResolver：" + typeIdResolver);
        Class<?> defaultImpl = typeDeserializer.getDefaultImpl();
        System.out.println("defaultImpl：" + defaultImpl);
        return deserialize(p, ctxt);
    }
}
```

# 6. 混入的注意事项
1. 避免命名冲突：当将 Mixin 混入到目标类时，要确保混入的方法和属性名称不会与目标类中已有的方法或属性名称冲突。如果有冲突，可能会导致运行时错误或不可预期的行为。
2. 谨慎处理覆盖方法：如果 Mixin 和目标类中都定义了相同的方法，那么在使用 Mixin 时要特别小心。通常，Mixin 中定义的方法会覆盖目标类中的同名方法。在使用覆盖的方法时，要确保它们的行为是符合预期的，并且不会对目标类的功能造成不良影响。
3. 确保 Mixin 的独立性：Mixin 应该具有相对独立的职责，并且不应该依赖于目标类的特定实现。这样可以确保 Mixin 的复用性和可维护性。
4. 避免过度使用 Mixin：虽然 Mixin 可以提高代码的复用性和可维护性，但过度使用 Mixin 也可能导致代码结构变得复杂和混乱。因此，应该根据实际需求合理使用 Mixin，避免过度混入多个 Mixin 到同一个类中。
5. 注意 Mixin 的生命周期：在处理生命周期相关的方法（如构造函数、析构函数等）时，要特别小心。如果 Mixin 中定义了这些方法，它们可能会干扰目标类的生命周期行为。需要确保 Mixin 中定义的这些方法与目标类的生命周期协调一致。

# 7. 基于 mixin 解决 spring-security 中 OAuth2AccessToken 和 OAuth2Authentication 的序列化反序列化问题
## 7.1 OAuth2AccessToken 的序列化反序列化问题
1. OAuth2AccessToken 自定义了序列化反序列化的类，能够进行序列化反序列化
```java
@org.codehaus.jackson.map.annotate.JsonSerialize(using = OAuth2AccessTokenJackson1Serializer.class)
@org.codehaus.jackson.map.annotate.JsonDeserialize(using = OAuth2AccessTokenJackson1Deserializer.class)
@com.fasterxml.jackson.databind.annotation.JsonSerialize(using = OAuth2AccessTokenJackson2Serializer.class)
@com.fasterxml.jackson.databind.annotation.JsonDeserialize(using = OAuth2AccessTokenJackson2Deserializer.class)
public interface OAuth2AccessToken {
}
```
2. @JsonDeserialize、@JsonSerialize 可以直接用在类上，效果等同于
```
ObjectMapper objectMapper = new ObjectMapper();
SimpleModule simpleModule = new SimpleModule();
simpleModule.addSerializer(OAuth2AccessToken.class, new OAuth2AccessTokenJackson2Serializer());
simpleModule.addDeserializer(OAuth2AccessToken.class, new OAuth2AccessTokenJackson2Deserializer());
objectMapper.registerModule(simpleModule);
```
## 7.2 OAuth2Authentication 的序列化反序列化问题
OAuth2Authentication 没有默认的构造函数，所以在反序列化的时候会报错：没有无参构造方法
### 7.2.1 解决方法 (Mixin 混入)
#### 1. 使用 @JsonCreator 注解指定构造方法
**不推荐**：因为 OAuth2Authentication 的构造函数参数是2个对象，且这2个对象都是复杂对象（内嵌着对象），所以使用 @JsonCreator 注解指定构造方法的方式不推荐
#### 2. 自定义反序列化类 OAuth2AuthenticationDeserializer
com.example.demo.json.deserializer.OAuth2AuthenticationDeserializer

#### 3. 将 OAuth2AuthenticationDeserializer 注册进 ObjectMapper 中
```
ObjectMapper objectMapper = new ObjectMapper();
SimpleModule simpleModule = new SimpleModule();
simpleModule.addDeserializer(OAuth2Authentication.class, new OAuth2AuthenticationDeserializer());
objectMapper.registerModule(simpleModule);
```
#### 4. 也可以创建一个 mixin 类 OAuth2AuthenticationMixin 注册进 ObjectMapper 中
```java
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class")
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY, getterVisibility = JsonAutoDetect.Visibility.NONE,
        isGetterVisibility = JsonAutoDetect.Visibility.NONE)
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonDeserialize(using = OAuth2AuthenticationDeserializer.class)
public abstract class OAuth2AuthenticationMixin {
}
```
注册进 ObjectMapper 中
```
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.addMixIn(OAuth2Authentication.class, OAuth2AuthenticationMixin.class);
```

# 8. 将spring-security 自带的 mixin module - CoreJackson2Module 注册进入 ObjectMapper 中
```
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.registerModule(new CoreJackson2Module());
```
将这个 module 注册进入 ObjectMapper 中后，就会出现一些问题
## 问题1
1. OAuth2AccessToken 序列化反序列化报错：type id missing
2. OAuth2Authentication 序列化反序列化报错：type id missing
### 原因
CoreJackson2Module 会将所有的类都添加上 @JsonTypeInfo 注解，所以会出现上面的问题
看下 CoreJackson2Module 的源码
```java
public class CoreJackson2Module extends SimpleModule {

	public CoreJackson2Module() {
		super(CoreJackson2Module.class.getName(), new Version(1, 0, 0, null, null, null));
	}

	@Override
	public void setupModule(SetupContext context) {
        // 将所有的类都添加上 @JsonTypeInfo 注解
		SecurityJackson2Modules.enableDefaultTyping(context.getOwner());
		context.setMixInAnnotations(AnonymousAuthenticationToken.class, AnonymousAuthenticationTokenMixin.class);
		context.setMixInAnnotations(RememberMeAuthenticationToken.class, RememberMeAuthenticationTokenMixin.class);
		context.setMixInAnnotations(SimpleGrantedAuthority.class, SimpleGrantedAuthorityMixin.class);
		context.setMixInAnnotations(Collections.<Object>unmodifiableSet(Collections.emptySet()).getClass(), UnmodifiableSetMixin.class);
		context.setMixInAnnotations(Collections.<Object>unmodifiableList(Collections.emptyList()).getClass(), UnmodifiableListMixin.class);
		context.setMixInAnnotations(User.class, UserMixin.class);
		context.setMixInAnnotations(UsernamePasswordAuthenticationToken.class, UsernamePasswordAuthenticationTokenMixin.class);
		context.setMixInAnnotations(BadCredentialsException.class, BadCredentialsExceptionMixin.class);
	}
}
```
enableDefaultTyping 方法
```
public static void enableDefaultTyping(ObjectMapper mapper) {
		if (mapper != null) {
			TypeResolverBuilder<?> typeBuilder = mapper.getDeserializationConfig().getDefaultTyper(null);
			if (typeBuilder == null) {
			    // 这里会将所有的类都添加上 @JsonTypeInfo 注解
				mapper.setDefaultTyping(createWhitelistedDefaultTyping());
			}
		}
	}
```
这里就相当于给所有的序列化反序列化类都添加上了 @JsonTypeInfo 注解
ObjectMapper.NON_FINAL：表示所有的目标类（JavaType）不是 final 修饰且不是 TreeNode
- 如果是final修饰或者 TreeNode 则序列化反序列化类不会生成包装类  TypeWrappedDeserializer、TypeWrappedSerializer 
- final修饰或者 TreeNode 的 javaType 就可以认为是没有添加 @JsonTypeInfo 注解的类，没有type id missing 的问题
- @see com.fasterxml.jackson.databind.ObjectMapper.DefaultTypeResolverBuilder.useForType(JavaType)
- @see com.fasterxml.jackson.databind.ObjectMapper.DefaultTypeResolverBuilder.buildTypeDeserializer
- @see com.fasterxml.jackson.databind.ObjectMapper.DefaultTypeResolverBuilder.buildTypeSerializer
```
private static TypeResolverBuilder<? extends TypeResolverBuilder> createWhitelistedDefaultTyping() {
		TypeResolverBuilder<? extends TypeResolverBuilder>  result = new WhitelistTypeResolverBuilder(ObjectMapper.NON_FINAL);
		result = result.init(JsonTypeInfo.Id.CLASS, null);
		result = result.inclusion(JsonTypeInfo.As.PROPERTY);
		return result;
	}
```
### 解决
#### OAuth2AccessToken
1. 自定义序列化类 MysOAuth2AccessTokenJacksonSerializer，重写 serializeWithType 方法
```java
public class MysOAuth2AccessTokenJacksonSerializer extends StdSerializer<OAuth2AccessToken> {

    /**
     * 参考 {@link org.springframework.security.oauth2.common.OAuth2AccessTokenJackson2Serializer}
     */
    public MysOAuth2AccessTokenJacksonSerializer() {
        super(OAuth2AccessToken.class);
    }

    @Override
    public void serialize(OAuth2AccessToken token, JsonGenerator jgen, SerializerProvider provider) throws IOException {
        jgen.writeStartObject();
        doSerialize(token, jgen);
        jgen.writeEndObject();
    }

    private void doSerialize(OAuth2AccessToken token, JsonGenerator jgen) throws IOException {
        jgen.writeStringField(OAuth2AccessToken.ACCESS_TOKEN, token.getValue());
        jgen.writeStringField(OAuth2AccessToken.TOKEN_TYPE, token.getTokenType());
        OAuth2RefreshToken refreshToken = token.getRefreshToken();
        if (refreshToken != null) {
            jgen.writeStringField(OAuth2AccessToken.REFRESH_TOKEN, refreshToken.getValue());
        }
        Date expiration = token.getExpiration();
        if (expiration != null) {
            long now = System.currentTimeMillis();
            jgen.writeNumberField(OAuth2AccessToken.EXPIRES_IN, (expiration.getTime() - now) / 1000);
        }
        Set<String> scope = token.getScope();
        if (scope != null && !scope.isEmpty()) {
            StringBuffer scopes = new StringBuffer();
            for (String s : scope) {
                Assert.hasLength(s, "Scopes cannot be null or empty. Got " + scope + "");
                scopes.append(s);
                scopes.append(" ");
            }
            jgen.writeStringField(OAuth2AccessToken.SCOPE, scopes.substring(0, scopes.length() - 1));
        }
        Map<String, Object> additionalInformation = token.getAdditionalInformation();
        if (additionalInformation != null) {
            for (String key : additionalInformation.keySet()) {
                jgen.writeObjectField(key, additionalInformation.get(key));
            }
        }
    }

    @Override
    public void serializeWithType(OAuth2AccessToken value, JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException {
        gen.writeStartObject();
        if (typeSer != null) {
            String className = OAuth2AccessToken.class.getName();
            // value 是否是代理类，如果是代理类，获取代理类的真实类型
            if (Proxy.isProxyClass(value.getClass())) {
                // 取 OAuth2AccessToken 接口的实现类
                Class<?>[] interfaces = value.getClass().getInterfaces();
                for (Class<?> clazz :interfaces){
                    if (OAuth2AccessToken.class.isAssignableFrom(clazz)){
                        className = clazz.getName();
                        break;
                    }
                }
            }
            gen.writeStringField(typeSer.getPropertyName(), className);
        }
        doSerialize(value, gen);
        gen.writeEndObject();
    }
}
```
2. 自定义反序列化类 MyOAuth2AccessTokenJacksonDeserializer，重写 deserializeWithType 方法
```java
public class MyOAuth2AccessTokenJacksonDeserializer extends StdDeserializer<OAuth2AccessToken> {

    /**
     * 参考 {@link org.springframework.security.oauth2.common.OAuth2AccessTokenJackson2Deserializer}
     */
    public MyOAuth2AccessTokenJacksonDeserializer() {
        super(OAuth2AccessToken.class);
    }

    @Override
    public OAuth2AccessToken deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException,
            JsonProcessingException {

        String tokenValue = null;
        String tokenType = null;
        String refreshToken = null;
        Long expiresIn = null;
        Set<String> scope = null;
        Map<String, Object> additionalInformation = new LinkedHashMap<String, Object>();

        // TODO What should occur if a parameter exists twice
        while (jp.nextToken() != JsonToken.END_OBJECT) {
            String name = jp.getCurrentName();
            jp.nextToken();
            if (OAuth2AccessToken.ACCESS_TOKEN.equals(name)) {
                tokenValue = jp.getText();
            }
            else if (OAuth2AccessToken.TOKEN_TYPE.equals(name)) {
                tokenType = jp.getText();
            }
            else if (OAuth2AccessToken.REFRESH_TOKEN.equals(name)) {
                refreshToken = jp.getText();
            }
            else if (OAuth2AccessToken.EXPIRES_IN.equals(name)) {
                try {
                    expiresIn = jp.getLongValue();
                } catch (JsonParseException e) {
                    expiresIn = Long.valueOf(jp.getText());
                }
            }
            else if (OAuth2AccessToken.SCOPE.equals(name)) {
                scope = parseScope(jp);
            } else {
                additionalInformation.put(name, jp.readValueAs(Object.class));
            }
        }

        // TODO What should occur if a required parameter (tokenValue or tokenType) is missing?

        DefaultOAuth2AccessToken accessToken = new DefaultOAuth2AccessToken(tokenValue);
        accessToken.setTokenType(tokenType);
        if (expiresIn != null) {
            accessToken.setExpiration(new Date(System.currentTimeMillis() + (expiresIn * 1000)));
        }
        if (refreshToken != null) {
            accessToken.setRefreshToken(new DefaultOAuth2RefreshToken(refreshToken));
        }
        accessToken.setScope(scope);
        accessToken.setAdditionalInformation(additionalInformation);

        return accessToken;
    }

    @Override
    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
        return deserialize(p, ctxt);
    }

    private Set<String> parseScope(JsonParser jp) throws JsonParseException, IOException {
        Set<String> scope;
        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {
            scope = new TreeSet<String>();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                scope.add(jp.getValueAsString());
            }
        } else {
            String text = jp.getText();
            scope = OAuth2Utils.parseParameterList(text);
        }
        return scope;
    }
}
```
3. 创建一个 mixin 类 OAuth2AccessTokenMixin 注册进 ObjectMapper 中
```java
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class")
@JsonSerialize(using = MysOAuth2AccessTokenJacksonSerializer.class)
@JsonDeserialize(using = MyOAuth2AccessTokenJacksonDeserializer.class)
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY, getterVisibility = JsonAutoDetect.Visibility.NONE,
        isGetterVisibility = JsonAutoDetect.Visibility.NONE)
@JsonIgnoreProperties(ignoreUnknown = true)
public abstract class MyOAuth2AccessTokenJacksonMixin {
}
```
4. 将 mixin 类注册进 ObjectMapper 中
```
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.addMixIn(OAuth2AccessToken.class, MyOAuth2AccessTokenJacksonMixin.class);
```
#### OAuth2Authentication
1. 自定义反序列化类 MyOAuth2AccessTokenJacksonDeserializer，重写 deserializeWithType 方法
```java
public class OAuth2AuthenticationDeserializer extends StdDeserializer<OAuth2Authentication> {

   public OAuth2AuthenticationDeserializer() {
      super(OAuth2Authentication.class);
   }

   @Override
   public OAuth2Authentication deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
      OAuth2Authentication oAuth2Authentication = doDeserialize(jp);
      return oAuth2Authentication;
   }

   private OAuth2Authentication doDeserialize(JsonParser jp) throws IOException {
      Set<String> authorities = null;
      Object details = null;
      boolean authenticated = false;
      Authentication userAuthentication = null;
      boolean clientOnly = false;
      String principal = null;
      String credentials = null;
      OAuth2Request oauth2Request = null;
      String name = null;

      ObjectMapper objectMapper = (ObjectMapper) jp.getCodec();
      ObjectNode root = objectMapper.readTree(jp);
      Iterator<Map.Entry<String, JsonNode>> elementsIterator = root.fields();
      while (elementsIterator.hasNext()) {
         Map.Entry<String, JsonNode> element = elementsIterator.next();
         String fieldname = element.getKey();
         JsonNode jsonNode = element.getValue();

         if ("authorities".equals(fieldname)) {
            authorities = jsonNode.findValuesAsText("authorities").stream().filter(StringUtils::hasText).collect(Collectors.toSet());
         } else if ("details".equals(fieldname)) {
            /**
             * 参考了一下：
             * @see UsernamePasswordAuthenticationTokenDeserializer#deserialize(JsonParser, DeserializationContext)
             */
            JsonNode detailsNode = readJsonNode(jsonNode, "details");
            if (detailsNode.isNull() || detailsNode.isMissingNode()) {
               details = null;
            } else {
               details = objectMapper.readValue(detailsNode.toString(), new TypeReference<Object>() {});
            }
         } else if ("authenticated".equals(fieldname)) {
            authenticated = jsonNode.booleanValue();
         } else if ("userAuthentication".equals(fieldname)) {
            /**
             * 使用 TypeReference<Authentication> 能够解决一些报错问题
             * 实际效果还有待实际使用验证，再去进行改进
             */
            userAuthentication = objectMapper.readValue(jsonNode.traverse(), new TypeReference<Authentication>() {});
         } else if ("clientOnly".equals(fieldname)) {
            clientOnly = jsonNode.booleanValue();
         } else if ("principal".equals(fieldname)) {
            principal = jsonNode.textValue();
         } else if ("oauth2Request".equals(fieldname)) {
            oauth2Request = parseOAuth2Request(jsonNode);
         } else if ("credentials".equals(fieldname)) {
            credentials = jsonNode.textValue();
         } else if ("name".equals(fieldname)) {
            name = jsonNode.textValue();
         }
      }

      OAuth2Authentication oAuth2Authentication = new OAuth2Authentication(oauth2Request, userAuthentication);
      oAuth2Authentication.setAuthenticated(authenticated);
      oAuth2Authentication.setDetails(details);
      return oAuth2Authentication;
   }


   private JsonNode readJsonNode(JsonNode jsonNode, String field) {
      return jsonNode.has(field) ? jsonNode.get(field) : MissingNode.getInstance();
   }

   @Override
   public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
      return deserialize(p, ctxt);
   }

   private OAuth2Request parseOAuth2Request(JsonNode jsonNode) throws IOException {
      JsonNode requestParametersJsonNode = jsonNode.findValue("requestParameters");

      /**
       * Map<String, String> requestParameters =
       *                 objectMapper.readValue(requestParametersJsonNode.traverse(), new TypeReference<Map<String, String>>() {});
       * 不能使用上面的方式   Map -> {@link com.fasterxml.jackson.databind.deser.std.MapDeserializer}
       * 因为 {@link org.springframework.security.jackson2.CoreJackson2Module} 的原因走的是
       * {@link MapDeserializer#deserializeWithType(JsonParser, DeserializationContext, TypeDeserializer)} 会报错 type id missing
       */
      Map<String, String> requestParameters = new HashMap<>();
      Iterator<Map.Entry<String, JsonNode>> iterator = requestParametersJsonNode.fields();
      while (iterator.hasNext()) {
         Map.Entry<String, JsonNode> entry = iterator.next();
         requestParameters.put(entry.getKey(), entry.getValue().textValue());
      }

      String clientId = jsonNode.get("clientId").textValue();
      String grantType = jsonNode.get("grantType").textValue();
      String redirectUri = jsonNode.get("redirectUri").textValue();
      boolean approved = jsonNode.get("approved").booleanValue();
      Set<String> responseTypes = jsonNode.findValuesAsText("responseTypes").stream().filter(StringUtils::hasText).collect(Collectors.toSet());


      Set<String> scope = jsonNode.findValuesAsText("scope").stream().filter(StringUtils::hasText).collect(Collectors.toSet());

      Set<String> authorities = jsonNode.findValuesAsText("authorities").stream().filter(StringUtils::hasText).collect(Collectors.toSet());
      Set<GrantedAuthority> grantedAuthorities = new HashSet<>(0);
      if (authorities != null && !authorities.isEmpty()) {
         authorities.forEach(s -> grantedAuthorities.add(new SimpleGrantedAuthority(s)));
      }

      Set<String> resourceIds = jsonNode.findValuesAsText("resourceIds").stream().filter(StringUtils::hasText).collect(Collectors.toSet());

      Map<String, Serializable> extensions = new HashMap<>();
      Iterator<Map.Entry<String, JsonNode>> extensionsIterator = jsonNode.get("extensions").fields();
      while (extensionsIterator.hasNext()) {
         Map.Entry<String, JsonNode> entry = extensionsIterator.next();
         extensions.put(entry.getKey(), entry.getValue().textValue());
      }

      OAuth2Request request = new OAuth2Request(requestParameters, clientId,
              grantedAuthorities, approved, scope, resourceIds, redirectUri, responseTypes, extensions);
      TokenRequest tokenRequest = new TokenRequest(requestParameters, clientId, scope, grantType);
      request = request.refresh(tokenRequest);
      return request;
   }
}
```
2. 创建一个 mixin 类 OAuth2AuthenticationMixin 注册进 ObjectMapper 中

```java
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class")
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY, getterVisibility = JsonAutoDetect.Visibility.NONE,
        isGetterVisibility = JsonAutoDetect.Visibility.NONE)
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonDeserialize(using = OAuth2AuthenticationDeserializer.class)
@JsonSerialize(using = OAuth2AuthenticationSerializer.class)
public abstract class OAuth2AuthenticationMixin {
}
```
3. 将 mixin 类注册进 ObjectMapper 中
```
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.addMixIn(OAuth2Authentication.class, OAuth2AuthenticationMixin.class);
```
## 问题2 
如果没有自定义 JavaType 对应的序列化类，那么JavaType 在走 com.fasterxml.jackson.databind.ser.BeanSerializer#serialize 的序列化方法，JavaType 对象的
每个属性都会去找对应的序列化类 -> 属性不是基本类型的话，每个属性对象转成 json 串后都会有一个 @class 属性
### 原因
原因同上，CoreJackson2Module 会将所有的类都添加上 @JsonTypeInfo 注解，所以会出现上面的问题
### 解决
自定义序列化类
```java
public class OAuth2AuthenticationSerializer extends StdSerializer<OAuth2Authentication> {
   public OAuth2AuthenticationSerializer() {
      super(OAuth2Authentication.class);
   }

   @Override
   public void serialize(OAuth2Authentication value, JsonGenerator gen, SerializerProvider provider) throws IOException {
      gen.writeStartObject();
      doSerialize(value, gen, null);
      gen.writeEndObject();
   }

   private static void doSerialize(OAuth2Authentication value, JsonGenerator gen, String typeIdName) throws IOException {
      gen.writeBooleanField("authenticated", value.isAuthenticated());
      gen.writeBooleanField("clientOnly", value.isClientOnly());
      gen.writeStringField("principal", value.getPrincipal() == null ? "" : value.getPrincipal().toString());
      gen.writeStringField("credentials", value.getCredentials() == null ? "" : value.getCredentials().toString());
      gen.writeStringField("name", value.getName());

      writeAuthorities(gen, value.getAuthorities());

      writeObject(gen, "details", value.getDetails());

      writeObject(gen, "userAuthentication", value.getUserAuthentication());

      gen.writeObjectFieldStart("oauth2Request");
      // OAuth2Request 对象 json 序列化
      OAuth2Request oAuth2Request = value.getOAuth2Request();
      if (oAuth2Request != null) {
         gen.writeStringField("clientId", oAuth2Request.getClientId());
         gen.writeStringField("grantType", oAuth2Request.getGrantType());
         gen.writeStringField("redirectUri", oAuth2Request.getRedirectUri());
         gen.writeBooleanField("approved", oAuth2Request.isApproved());
         gen.writeBooleanField("refresh", oAuth2Request.isRefresh());

         writeExtensions(gen, oAuth2Request);

         gen.writeObjectField("refreshTokenRequest", oAuth2Request.getRefreshTokenRequest());

         writeStringArray(gen, "resourceIds", oAuth2Request.getResourceIds());

         writeStringArray(gen, "responseTypes", oAuth2Request.getResponseTypes());

         writeAuthorities(gen, oAuth2Request.getAuthorities());

         writeStringArray(gen, "scope", oAuth2Request.getScope());

         writeRequestParameters(gen, oAuth2Request);
      }
      gen.writeEndObject();
   }

   private static void writeObject(JsonGenerator gen, String fieldName, Object value) throws IOException {
      gen.writeObjectField(fieldName, value);
   }

   private static void writeObjectWithTypeId(String fieldName, Object value, Class<?> valueClass, JsonGenerator gen, String typeIdName) throws IOException {
      gen.writeObjectFieldStart(fieldName);
      if (StringUtils.hasText(typeIdName)) {
         gen.writeStringField(typeIdName, valueClass.getName());
      }
      gen.writeObjectField(fieldName, value);
      gen.writeEndObject();
   }

   private static void writeExtensions(JsonGenerator gen, OAuth2Request oAuth2Request) throws IOException {
      gen.writeObjectFieldStart("extensions");
      Map<String, Serializable> extensions = oAuth2Request.getExtensions();
      if (!CollectionUtils.isEmpty(extensions)) {
         for (Map.Entry<String, Serializable> entry : extensions.entrySet()) {
            gen.writeObjectField(entry.getKey(), entry.getValue());
         }
      }
      gen.writeEndObject();
   }

   private static void writeAuthorities(JsonGenerator gen, Collection<? extends GrantedAuthority> authorities) throws IOException {
      gen.writeArrayFieldStart("authorities");
      if (!CollectionUtils.isEmpty(authorities)) {
         for (GrantedAuthority authority : authorities) {
            gen.writeString(authority.getAuthority());
         }
      }
      gen.writeEndArray();
   }

   private static void writeRequestParameters(JsonGenerator gen, OAuth2Request oAuth2Request) throws IOException {
      gen.writeObjectFieldStart("requestParameters");
      Map<String, String> requestParameters = oAuth2Request.getRequestParameters();
      if (!CollectionUtils.isEmpty(requestParameters)) {
         for (Map.Entry<String, String> entry : requestParameters.entrySet()) {
            gen.writeStringField(entry.getKey(), entry.getValue());
         }
      }
      gen.writeEndObject();
   }

   private static void writeStringArray(JsonGenerator gen, String fieldName, Collection<String> collection) throws IOException {
      gen.writeArrayFieldStart(fieldName);
      if (!CollectionUtils.isEmpty(collection)) {
         for (String value : collection) {
            gen.writeString(value);
         }
      }
      gen.writeEndArray();
   }

   @Override
   public void serializeWithType(OAuth2Authentication value, JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException {
      gen.writeStartObject();
      if (typeSer != null) {
         String className = OAuth2Authentication.class.getName();
         // value 是否是代理类，如果是代理类，获取代理类的真实类型
         if (Proxy.isProxyClass(value.getClass())) {
            // 取 OAuth2Authentication 接口的实现类
            Class<?>[] interfaces = value.getClass().getInterfaces();
            for (Class<?> clazz :interfaces){
               if (OAuth2Authentication.class.isAssignableFrom(clazz)){
                  className = clazz.getName();
                  break;
               }
            }
         }
         gen.writeStringField(typeSer.getPropertyName(), className);
      }
      doSerialize(value, gen, typeSer.getPropertyName());
      gen.writeEndObject();
   }
}
```

# 9. 源码流程
```java
public class JacksonSourceCodeApp {
    public static void main(String[] args) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
//        objectMapper.addMixIn(OAuth2AccessToken.class, MyOAuth2AccessTokenJacksonMixin.class);
//        SimpleModule simpleModule = new SimpleModule();
//        simpleModule.addDeserializer(OAuth2Authentication.class, new OAuth2AuthenticationDeserializer());
//        objectMapper.registerModule(simpleModule);
        MyUser myUser = new MyUser("test", "hello");

        objectMapper.addMixIn(MyUser.class, MyUserMixin.class);

        /**
         * 序列化源码流程：
         * @see com.fasterxml.jackson.databind.ObjectMapper#_configAndWriteValue(com.fasterxml.jackson.core.JsonGenerator, java.lang.Object)
         * @see DefaultSerializerProvider#serializeValue(JsonGenerator, Object)
         * @see SerializerProvider#findTypedValueSerializer(Class, boolean, BeanProperty)
         *      - {@link SerializerProvider#findValueSerializer(Class, BeanProperty)} 找目标对象匹配的序列化类
         *           - {@link SerializerProvider#_createUntypedSerializer(JavaType)}
         *           - {@link BeanSerializerFactory#createSerializer(SerializerProvider, JavaType)}
         *           - {@link BasicSerializerFactory#findSerializerFromAnnotation(SerializerProvider, Annotated)}
         *           - {@link JacksonAnnotationIntrospector#findSerializer(Annotated)}
         *      - {@link BasicSerializerFactory#createTypeSerializer(SerializationConfig, JavaType)} 创建目标对象的序列化类型信息
         *           - {@link ObjectMapper.DefaultTypeResolverBuilder#buildTypeSerializer(SerializationConfig, JavaType, Collection)}
         *              如果注册进来了 {@link org.springframework.security.jackson2.CoreJackson2Module}
         *              -> 注册了 {@link org.springframework.security.jackson2.CoreJackson2Module}
         *              -> {@link SecurityJackson2Modules#createWhitelistedDefaultTyping()}
         *              -> 匹配 NON_FINAL {@link ObjectMapper.DefaultTypeResolverBuilder#useForType(JavaType)}
         *                  -> JavaType 不是 final 修饰且不是 TreeNode 类型则会去创建 TypeSerializer，否则 TypeSerializer 为 null
         *                  -> JavaType 匹配则执行 {@link StdTypeResolverBuilder#buildTypeDeserializer(DeserializationConfig, JavaType, Collection)} 创建 TypeSerializer
         *      - 如果 createTypeSerializer 返回的不是 null 则创建 {@link TypeWrappedSerializer} 包装类对实际的序列化类进行包装
         * @see com.fasterxml.jackson.databind.ser.DefaultSerializerProvider#_serialize(com.fasterxml.jackson.core.JsonGenerator, java.lang.Object, com.fasterxml.jackson.databind.JsonSerializer)
         *      - 如果 findTypedValueSerializer 返回的是 JsonSerializer 是包装类 {@link com.fasterxml.jackson.databind.ser.impl.TypeWrappedSerializer} 则进入
         *          - {@link TypeWrappedSerializer#serialize(Object, JsonGenerator, SerializerProvider)} 最终调用的是 实际的序列化类的 serializeWithType 方法
         *          - 如果序列化类没有实现 serializeWithType 方法则会报错 type id handling not implemented for type
         *      - 如果 {@link SerializerProvider#findTypedValueSerializer} 返回的 JsonSerializer 是实际的序列化类则直接调用序列化类的 serialize 方法
         */
        String s = objectMapper.writeValueAsString(myUser);
        System.out.println(s);

//        String json = "{\"@class\":\"com.example.demo.testMixin.MyUser\",\"username\":\"test\",\"realname\":\"hello\"}";
        String json = "{\"username\":\"test\",\"realname\":\"hello\"}";

        /**
         * 反序列化源码流程：
         * @see ObjectMapper#_readMapAndClose(JsonParser, JavaType)
         * @see _findRootDeserializer(ctxt, valueType) -> {@link ObjectMapper#_findRootDeserializer(DeserializationContext, JavaType)}
         *      - {@link DeserializationContext#findRootValueDeserializer(JavaType)}
         *      - _factory.findTypeDeserializer(_config, type) -> {@link BasicDeserializerFactory#findTypeDeserializer(DeserializationConfig, JavaType)}
         *          - b.buildTypeDeserializer(config, baseType, subtypes) -> {@link ObjectMapper.DefaultTypeResolverBuilder#buildTypeDeserializer(DeserializationConfig, JavaType, Collection)}
         *          - useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null
         *              - {@link ObjectMapper.DefaultTypeResolverBuilder#useForType(JavaType)} JavaType 匹配
         *                  则执行 {@link StdTypeResolverBuilder#buildTypeDeserializer(DeserializationConfig, JavaType, Collection)} 创建 {@link com.fasterxml.jackson.databind.jsontype.TypeDeserializer}
         *      - 如果 {@link DeserializationContext#findRootValueDeserializer(JavaType)} 返回的 {@link TypeWrappedDeserializer} 不为null
         *          则创建包装类 {@link TypeWrappedDeserializer} 对实际的反序列化类进行包装
         * @see deser.deserialize(p, ctxt)
         *      - 如果 {@link ObjectMapper#_findRootDeserializer} 返回的是包装类 {@link com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer} 则进入
         *          - {@link TypeWrappedDeserializer#deserialize(JsonParser, DeserializationContext)} 最终调用的是实际的反序列化类的 deserializeWithType 方法
         *          -> 以 @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class") 为例
         *          - {@link AsPropertyTypeDeserializer#deserializeTypedFromAny(JsonParser, DeserializationContext)}
         *          - {@link AsPropertyTypeDeserializer#deserializeTypedFromObject(JsonParser, DeserializationContext)}
         *              - if (name.equals(_typePropertyName)
         *                     || (ignoreCase && name.equalsIgnoreCase(_typePropertyName))) 如果json串中包含 @class 属性则进入
         *                  - {@link AsPropertyTypeDeserializer#_deserializeTypedForId(JsonParser, DeserializationContext, TokenBuffer)}
         *                  - deser.deserialize(p, ctxt) -> 进入实际的反序列化类的 deserialize 方法
         *                  >>> 这种 反序列类没有实现 deserializeWithType 方法但是 json 串中包含 @class 属性的情况下是能够正常反序列化的
         *              - 如果 json 串中不包含 @class 属性则进入
         *              -> {@link AsPropertyTypeDeserializer#_deserializeTypedUsingDefaultImpl(JsonParser, DeserializationContext, TokenBuffer)}
         *              >>> 这种 反序列类没有实现 deserializeWithType 方法且 json 串中不包含 @class 属性的情况下是不能够正常反序列化的
         *              >>> 除非设置了 defaultImpl （具体怎么弄就不研究了）
         *      - 如果 {@link ObjectMapper#_findRootDeserializer} 返回的是实际的反序列化类则直接调用反序列化类的 deserialize 方法
         */
        MyUser jsonUser = objectMapper.readValue(json, MyUser.class);
        System.out.println(jsonUser);
    }
}
```
# 10. @JsonSubTypes 注解的使用
## 10.1 @JsonSubTypes 注解的作用
@JsonSubTypes 注解的作用是：指定子类的类型信息，用于序列化和反序列化
## 10.2 @JsonSubTypes 注解的使用
1. 创建一个抽象类 AbstractChecker，添加 @JsonTypeInfo、@JsonSubTypes 注解，添加子类 HttpChecker、MysqlChecker
```java
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type", defaultImpl = AbstractHealthChecker.None.class)
@JsonSubTypes({@JsonSubTypes.Type(name = HttpChecker.TYPE, value = HttpChecker.class),
        @JsonSubTypes.Type(name = MysqlChecker.TYPE, value = MysqlChecker.class),
        @JsonSubTypes.Type(name = AbstractChecker.None.TYPE, value = AbstractChecker.None.class)})
public abstract class AbstractChecker {
/**
 * copy from {@link com.alibaba.nacos.api.naming.pojo.healthcheck.AbstractHealthChecker}
  */
    @JsonIgnore
    protected final String type;

    protected AbstractChecker(String type) {
        this.type = type;
    }

    public String getType() {
        return type;
    }

    /**
     * Default implementation of Health checker.
     */
    public static class None extends AbstractChecker {

        public static final String TYPE = "NONE";

        public None() {
            super(TYPE);
        }

    }
}

public class HttpChecker extends AbstractChecker {
   public static final String TYPE = "HTTP";

   private String path = "";

   private String headers = "";

   private int expectedResponseCode = 200;

   public HttpChecker() {
      super(HttpChecker.TYPE);
   }

   public int getExpectedResponseCode() {
      return this.expectedResponseCode;
   }

   public void setExpectedResponseCode(final int expectedResponseCode) {
      this.expectedResponseCode = expectedResponseCode;
   }

   public String getPath() {
      return this.path;
   }

   public void setPath(final String path) {
      this.path = path;
   }

   public String getHeaders() {
      return this.headers;
   }

   public void setHeaders(final String headers) {
      this.headers = headers;
   }

   @JsonIgnore
   public Map<String, String> getCustomHeaders() {
      if (StringUtils.isBlank(headers)) {
         return Collections.emptyMap();
      }
      final Map<String, String> headerMap = new HashMap<String, String>(16);
      for (final String s : headers.split(Constants.NAMING_HTTP_HEADER_SPILIER)) {
         final String[] splits = s.split(":");
         if (splits.length != 2) {
            continue;
         }
         headerMap.put(StringUtils.trim(splits[0]), StringUtils.trim(splits[1]));
      }
      return headerMap;
   }

}

public class MysqlChecker extends AbstractChecker {
   public static final String TYPE = "MYSQL";

   private String user;

   private String pwd;

   private String cmd;

   public MysqlChecker() {
      super(Mysql.TYPE);
   }

   public String getCmd() {
      return this.cmd;
   }

   public String getPwd() {
      return this.pwd;
   }

   public String getUser() {
      return this.user;
   }

   public void setUser(final String user) {
      this.user = user;
   }

   public void setCmd(final String cmd) {
      this.cmd = cmd;
   }

   public void setPwd(final String pwd) {
      this.pwd = pwd;
   }
}
```
2. 测试及源码流程
```java
public class TestSubTypeApp {
    public static void main(String[] args) {
        ObjectMapper objectMapper = new ObjectMapper();

        HttpChecker httpChecker = new HttpChecker();
        httpChecker.setPath("http://www.baidu.com");
        httpChecker.setHeaders("this is header");
        // 序列化
        try {
            String json = objectMapper.writeValueAsString(httpChecker);
            System.out.println(json);

            /**
             * 反序列化
             * 设计 subtype 的主要源码：
             * @see com.fasterxml.jackson.databind.deser.BasicDeserializerFactory#findTypeDeserializer(com.fasterxml.jackson.databind.DeserializationConfig, com.fasterxml.jackson.databind.JavaType)
             * -> config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac)  找subType 信息 -> {@link StdSubtypeResolver#collectAndResolveSubtypesByTypeId(MapperConfig, AnnotatedClass)}
             *      -> {@link StdSubtypeResolver#_collectAndResolveByTypeId(AnnotatedClass, NamedType, MapperConfig, Set, Map)}
             *      -> ai.findSubtypes(annotatedType) -> {@link JacksonAnnotationIntrospector#findSubtypes(Annotated)}
             * -> b.buildTypeDeserializer(config, baseType, subtypes)  构建 TypeDeserializer -> {@link StdTypeResolverBuilder#buildTypeDeserializer(DeserializationConfig, JavaType, Collection)}
             *      -> idResolver(config, baseType, subTypeValidator, subtypes, false, true) 构建 TypeIdResolver -> {@link StdTypeResolverBuilder#idResolver(MapperConfig, JavaType, PolymorphicTypeValidator, Collection, boolean, boolean)}
             *          -> {@link AbstractChecker}配置的是 JsonTypeInfo.Id.NAME -> 返回 {@link com.fasterxml.jackson.databind.jsontype.impl.TypeNameIdResolver}
             *      -> 返回 {@link AsPropertyTypeDeserializer}
             *
             * @see com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer#deserialize(JsonParser, DeserializationContext)
             *      -> {@link com.fasterxml.jackson.databind.deser.AbstractDeserializer#deserializeWithType(JsonParser, DeserializationContext, TypeDeserializer)}
             *      -> typeDeserializer.deserializeTypedFromObject(p, ctxt) -> {@link AsPropertyTypeDeserializer#deserializeTypedFromObject(JsonParser, DeserializationContext)}
             *          ->  if (name.equals(_typePropertyName)
             *                     || (ignoreCase && name.equalsIgnoreCase(_typePropertyName))) if (name.equals(_typePropertyName)
             *                     || (ignoreCase && name.equalsIgnoreCase(_typePropertyName))) 找到了属性名和配置的一样的属性
             *                  {@link AsPropertyTypeDeserializer#_deserializeTypedForId(JsonParser, DeserializationContext, TokenBuffer)}
             *                  -> _findDeserializer(ctxt, typeId) -> {@link TypeDeserializerBase#_findDeserializer(DeserializationContext, String)}
             *                      -> _idResolver.typeFromId(ctxt, typeId) -> {@link TypeNameIdResolver#typeFromId(DatabindContext, String)} 找到了对应的子类
             *                      -> 通常返回 {@link com.fasterxml.jackson.databind.deser.BeanDeserializer} -> 进行反序列化
             *
              */
            AbstractChecker abstractChecker = objectMapper.readValue(json, AbstractChecker.class);
            System.out.println(abstractChecker);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
